{"pages":[{"title":"日记","text":"月份跳转： 3月碎碎念 4月碎碎念 7月碎碎念 2023/3/21 TUES.今天背了很多单词，给博客换了一个好看的主题，但是有些markdown的语法显示不出来呜呜👻 Typora还挺好用的，打算付费支持一下，这个静态博客相当于帮我把.md的文件渲染上来，把需要的页面部署好啦 以后在Typora上编辑之后，直接用hexo g和hexo d这两个指令就可以上传到博客了！好耶！ hexo s运行之后是在本地打开http://localhost:4000/ 本来打算加个Qexo后端，懒得弄了，现在就挺方便哒🥳 （自带的表情还挺可爱的ヾ(≧▽≦*)o） 2023/3/22 WED. “我宣布二食堂的掉渣饼是世界上最好吃的掉渣饼” 天气快点好起来吧，下了好久的雨啦！！！！ 把博客的评论设置了一下，可以评论了 emmm本来想写个教程记录一下搭建的过程，但是太懒了以后有空再写。 今天要早睡早起🥰🥰 明天要看数据结构了🧐 晚上差点被车撞到了，隔得好近，脸跟车身只隔了几厘米 以后不能边走路边看手机边找人了，太危险了🚐 啊啊啊啊臭泥泥怪啊啊啊啊臭泥泥怪啊啊啊臭泥泥怪啊啊啊臭泥泥怪大学生哪有不发疯的！！！啊啊啊啊啊啊大学生哪有不发疯的！ 2023/3/24 FRI.昨天和今天都背了很多单词！（嗯！我是好孩子！） 递归和递推的题 看一下二分和前缀 我宣布四食堂一楼的鸡排饭里面的鸡排是江大最好吃的（没有之一！） 2023/4/1 SAT.要努力地掌握生产力的工具 2023/7/14 FRI.","link":"/about/index.html"},{"title":"杂","text":"这里本该是友链或者是自我介绍的，但是现在不是很需要这些功能就先空着吧","link":"/links/index.html"}],"posts":[{"title":"Hello World","text":"“欢迎来到我的博客” 这里本应该用来写怎么搭建这个博客，太懒了先鸽着 Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/03/20/hello-world/"},{"title":"markdown的使用说明","text":"跳转到：基础语法 这里用来记录写博客时用到的一些好用的markdown语法 文内锚点链接跳转 12&lt;a href=&quot;#基础语法&quot;&gt;&lt;font size=3 color=#0f6578&gt;基础语法&lt;/font&gt;&lt;/a&gt;&lt;a id=&quot;基础语法&quot;&gt;基础语法&lt;/a&gt; 效果： 基础语法 即可跳转到下文基础语法（原理就是通过id值跳转啦） 未完待续 基础语法一、标题语法：# (一级标题) ## (二级标题) ### (三级标题) …… 代码： 12# 这是一级标题## 这是二级标题 效果: 我是一级标题我是二级标题快捷键: Ctrl+数字1~6可以快速将选中的文本调成对应级别的标题 Ctrl+0可以快速将选中的文本调成普通文本 Ctrl+加号/减号对标题级别进行加减 二、段落1、换行代码: 12这是一个段落这是一个段落 效果: 这是一个段落这是一个段落 2、分割线语法: —或者***+回车 代码: 1---或者*** 效果: 三、文字显示1、字体语法: 粗体: 用一对双星号包裹 删除线: 用一对双飘号包裹 下划线: 用一对u标签包裹 斜体: 用一对单星号包裹 高亮: 用一对双等号包裹 代码: 12345**这是粗体**~~这是删除线~~&lt;u&gt;这是下划线&lt;/u&gt;*这是斜体*==这是高亮== 效果:这是粗体这是删除线这是下划线这是斜体 ==高亮== 快捷键: 加粗: Ctrl+B 删除线: Shift+Alt+5 下划线: Ctrl+U 斜体: Ctrl+I 四、列表1、无序列表代码: 1*空格 或者是 -空格 效果:1.只有同一级别: 苹果 香蕉 橘子 2.子集类: 一级分类 二级分类* 三级分类 快捷键: Ctrl+Shift+] 2、有序列表代码: 1数字+.+空格 效果: 第一个标题 第二个标题 第三个标题 子内容1 子内容2 第四个标题 快捷键: Ctrl+Shift+[ 3、任务列表代码: 12- [ ] 吃早餐- [x] 背单词 效果: 吃早餐 背单词 五、代码显示1、行内代码代码: 1`int a=0;`（说明：`位于Esc下面） 效果:int a=0; 快捷键: Ctrl+Shift+` 2、代码块代码: 123```js/java/c#/text内容``` 快捷键: Ctrl+Shift+K 六、链接代码: 123www.baidu.com[百度一下](https://www.baidu.com)[百度一下](https://www.baidu.com &quot;https://www.baidu.com&quot;) 效果:www.baidu.com百度一下百度一下 快捷键: Ctrl+K","link":"/2023/03/21/Typora/"},{"title":"递归与递推","text":"递归 1.递归实现指数型枚举 2.递归实现排列型枚举 递推 1.简单斐波那契 2.费解的开关 递归 1.递归实现指数型枚举 从 1∼n这 n个整数中随机选取任意多个，输出所有可能的选择方案。输入格式输入一个整数 n输出格式每行输出一种方案。同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。对于没有选任何数的方案，输出空行。数据范围1≤n≤15输入样例： 13 输出样例： 12345678322 311 31 21 2 3 代码 状态压缩递归(yxc)： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int n;// u是当前枚举到的数，state是二进制数记录哪些数被选void dfs(int u, int state) { if (u == n) { for (int i = 0; i &lt; n; i ++) if (state &gt;&gt; i &amp; 1) //state的第i位的状态为1则输出 //如011，1是第0位 //输出1 2 cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return ; } dfs (u + 1, state); // 不用u这个数 dfs (u + 1, state | (1 &lt;&lt; u)); // 用u这个数}int main() { cin &gt;&gt; n; dfs(0, 0); return 0;} 题解： 左移右移的优先级高于与或运算 每个数都存在选中和不被选中两种情况，所以结果是2^n个 state保存的状态次序（只有一位和两位的状态在前面补0便于理解）： 000 100 010 110 001 101 011 111 自己用mermaid画了个流程图: (这个用代码画还挺方便的，两分钟画一个) 2.递归实现排列型枚举 把 1∼n这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。输入格式输入一个整数 n输出格式 按照从小到大的顺序输出所有方案，每行 11 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9输入样例： 13 输出样例： 1234561 2 31 3 22 1 32 3 13 1 23 2 1 代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n;int ans[10];//储存输出的数组int state[10];//判断该数字有没有使用void dfs(int u){ //到达边界 if(u &gt; n){ for(int i=1;i&lt;=n;i++){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return; } //没到达边界 for(int i = 1;i&lt;=n;i++){ //如果该数字没有被使用 if(state[i] == 0){ ans[u] = i; state[i] = 1; //前进 dfs(u+1); //回溯 state[i] = 0; } }}int main(){ cin&gt;&gt;n; dfs(1); return 0;} 用state记录数字使用状态，很经典的递归回溯 （图片源自acwing 递归实现排列型枚举—画图详解 - AcWing） 递推 1.简单斐波那契 以下数列 0 1 1 2 3 5 8 13 21 ... 被称为斐波纳契数列。 这个数列从第 33 项开始，每一项都等于前两项之和。 输入一个整数 N，请你输出这个序列的前 N项。输入格式一个整数 N。输出格式 在一行中输出斐波那契数列的前 N 项，数字之间用空格隔开。 数据范围0&lt;N&lt;46输入样例： 15 输出样例： 10 1 1 2 3 代码： f [ n ] = f [ n - 1 ] + f [ n - 2] 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main(){ int n,a[46]={0}; cin&gt;&gt;n; if(n == 1){ cout&lt;&lt;0; } else{ a[1] = 1; for(int i = 2;i &lt; n;i++){ a[i]=a[i-1]+a[i-2]; } for(int i = 0;i &lt; n;i++){ cout&lt;&lt;a[i]&lt;&lt;' '; } } return 0;} 2.费解的开关 你玩过“拉灯”游戏吗？ 2525 盏灯排成一个 5×55×5 的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。 下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。一个整数 N。输入格式第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。 以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。 每组数据描述了一个游戏的初始状态。 各组数据间用一个空行分隔。 输出格式 一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。 数据范围0&lt;n≤500输入样例： 1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例： 12332-1 代码：","link":"/2023/03/24/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"},{"title":"动态规划","text":"简单DP 1. 买不到的数目 2.递归实现排列型枚举 复杂DP 1.简单斐波那契 2.费解的开关 简单DP 1. 蚂蚁感冒 长 100 厘米的细长直杆子上有 n 只蚂蚁。 它们的头有的朝左，有的朝右。 每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。 当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。 这些蚂蚁中，有 1 只蚂蚁感冒了。 并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。 请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 输入格式 第一行输入一个整数 n, 表示蚂蚁的总数。 接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。 正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。 其中，第一个数据代表的蚂蚁感冒了。 输出格式输出1个整数，表示最后感冒蚂蚁的数目。数据范围1&lt;n&lt;50，0&lt;|Xi|&lt;100输入样例： 1235 -2 8 输出样例： 11 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main(){ int n,a[50],ans = 1; cin&gt;&gt;n; for(int i = 0;i &lt; n;i++){ cin&gt;&gt;a[i]; } for(int i = 1;i &lt; n;i++){ if(a[i] &gt; 0 &amp;&amp; abs(a[i]) &gt; abs(a[0])) continue; if(a[i] &lt; 0 &amp;&amp; abs(a[i]) &lt; abs(a[0])) continue; if(a[0] &gt; 0){ if(a[i] &lt; 0 &amp;&amp; abs(a[i]) &gt; abs(a[0])) ans++; if(a[i] &gt; 0 &amp;&amp; abs(a[i]) &lt; abs(a[0])){ for(int j = 1;j &lt; n;j++){ if(a[j] &lt; 0 &amp;&amp; abs(a[j]) &gt; abs(a[0])){ ans++; break; } } } } if(a[0] &lt; 0){ if(a[i] &gt; 0 &amp;&amp; abs(a[i]) &lt; abs(a[0])) ans++; if(a[i] &lt; 0 &amp;&amp; abs(a[i]) &gt; abs(a[0])){ for(int j = 1;j &lt; n;j++){ if(a[j] &gt; 0 &amp;&amp; abs(a[j]) &lt;abs(a[0])){ ans++; break; } } } } } cout&lt;&lt;ans; return 0;} 2.递归实现排列型枚举 把 1∼n这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。输入格式输入一个整数 n输出格式 按照从小到大的顺序输出所有方案，每行 11 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9输入样例： 13 输出样例： 1234561 2 31 3 22 1 32 3 13 1 23 2 1 代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n;int ans[10];//储存输出的数组int state[10];//判断该数字有没有使用void dfs(int u){ //到达边界 if(u &gt; n){ for(int i=1;i&lt;=n;i++){ cout&lt;&lt;ans[i]&lt;&lt;' '; } cout&lt;&lt;endl; return; } //没到达边界 for(int i = 1;i&lt;=n;i++){ //如果该数字没有被使用 if(state[i] == 0){ ans[u] = i; state[i] = 1; //前进 dfs(u+1); //回溯 state[i] = 0; } }}int main(){ cin&gt;&gt;n; dfs(1); return 0;} 用state记录数字使用状态，很经典的递归回溯 （图片源自acwing 递归实现排列型枚举—画图详解 - AcWing） 递推 1.简单斐波那契 以下数列 0 1 1 2 3 5 8 13 21 ... 被称为斐波纳契数列。 这个数列从第 33 项开始，每一项都等于前两项之和。 输入一个整数 N，请你输出这个序列的前 N项。输入格式一个整数 N。输出格式 在一行中输出斐波那契数列的前 N 项，数字之间用空格隔开。 数据范围0&lt;N&lt;46输入样例： 15 输出样例： 10 1 1 2 3 代码： f [ n ] = f [ n - 1 ] + f [ n - 2] 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main(){ int n,a[46]={0}; cin&gt;&gt;n; if(n == 1){ cout&lt;&lt;0; } else{ a[1] = 1; for(int i = 2;i &lt; n;i++){ a[i]=a[i-1]+a[i-2]; } for(int i = 0;i &lt; n;i++){ cout&lt;&lt;a[i]&lt;&lt;' '; } } return 0;} 2.费解的开关 你玩过“拉灯”游戏吗？ 2525 盏灯排成一个 5×55×5 的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。 下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。一个整数 N。输入格式第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。 以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。 每组数据描述了一个游戏的初始状态。 各组数据间用一个空行分隔。 输出格式 一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。 数据范围0&lt;n≤500输入样例： 1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例： 12332-1 代码：","link":"/2023/07/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"数论结论题","text":"1. 买不到的数目 2.递归实现排列型枚举 复杂DP 1.简单斐波那契 2.费解的开关 1. 买不到的数目 小明开了一家糖果店。 他别出心裁：把水果糖包成4颗一包和7颗一包的两种。 糖果不能拆包卖。 小朋友来买糖的时候，他就用这两种包装来组合。 当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。 你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。 大于17的任何数字都可以用4和7组合出来。 本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。 输入格式两个正整数 n,m，表示每种包装中糖的颗数。输出格式一个正整数，表示最大不能买到的糖数。数据范围2≤n,m≤1000，输入样例： 14 7 输出样例： 117 如果 a,b均是正整数且互质，那么由 ax+by,x≥0,y≥0， 不能凑出的最大数是 (a−1)(b−1)−1 12345678#include&lt;iostream&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;(n-1)*(m-1)-1;return 0;}","link":"/2023/07/13/%E7%BB%93%E8%AE%BA/"},{"title":"Qexo的搭建","text":"快速搭建QexoPart 1.planetscale1.注册planetscale账号，创建mysql数据库1https://app.planetscale.com/ 2.查看数据库连接信息 PASSWORD只能查看一次请注意保存 12345HOST=aws.connect.psdb.cloudUSERNAME=jdpips5xobaz5c5ey1suPASSWORD=手动打码DATABASE=blogdb 名称 意义 示例 MYSQL_HOST MySQL 数据库连接地址 aws.connect.psdb.cloud MYSQL_PORT MySQL 数据库通信端口 默认应填写 3306 3306 MYSQL_USER MySQL 数据库用户名 jdpips5xobaz5c5ey1su MYSQL_NAME MySQL 数据库名 blogdb MYSQL_PASSWORD MySQL 数据库密码 填自己生成的 PLANETSCALE (可选)用PlanetScale则设置为1 不要填，空着提交 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 ESGnA42qGe5kHZo86EIY0lry Storage – Dashboard – Vercel","link":"/2023/07/16/Qexo/"}],"tags":[{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"}]}